### 문제 링크

https://www.acmicpc.net/problem/1149

### 아이디어

처음에는 dfs를 이용해 완전탐색으로 구했으나 시간초과

모든 경우를 탐색하면 최악의 경우 O(2^1000 * 3)의 시간 복잡도를 갖게 되어 시간초과가 발생한다. 

따라서 dp를 이용해 i번째 집을 각각 R, G, B로 칠했을 때 그 이전까지의 최솟값을 저장하여 해결한다. 

`dp[i][j]`⇒ i번째 집을 j (0 ≤ j ≤ 2, 각각 R, G, B로 칠할 경우)로 칠했을 때 그 이전까지의 최솟값

만약 dp[i][0]이면 i번째 집을 빨간색으로 칠한 경우이므로 그 전의 집은 초록 또는 파랑으로 칠했어야 한다. 

따라서 dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2])이다.
