### 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/42890#qna

### 아이디어

1. 속성의 개수가 N개일 때, 1 ~ N개의 속성으로 이루어진 모든 후보키 쌍을 구한다. 
    
    ex. 1개 속성으로 이루어진 후보키 쌍 → [0], [1], [2] …
    
    2개 속성으로 이루어진 후보키 쌍 → [0, 1], [2, 3] …
    
2. DFS + 백트래킹을 이용해 i개의 속성으로 이루어진 후보키 쌍을 모두 구하고 keySet 리스트에 저장한다.  이 때 순서를 고려하지 않는다. (조합) 
    
    ex. [1, 2, 3] = [2, 1, 3]
    
3. 만들어진 i개의 속성으로 이루어진 후보키 쌍들을 이용했을 때, 모든 튜플들을 구별할 수 있는지, 즉 유일성과 최소성을 만족시키는 지 확인한다. 
    
    예를 들어 리스트로 구성된 [1, 2, 3]이 유일성을 만족시키면, [1, 2, 3]이 앞서 저장된 후보키 쌍으로 set에 저장된 [2], [1, 3]를 포함하는 지 확인한다. 이 때 list에서 제공하는 containsAll( )을 이용한다. 
    
    ex. [1, 2, 3].containsAll([1, 3]) = true ⇒ 최소성 만족 X
    

1. 저장된 모든 후보키를 카운트한다. 

처음 시도 때 최소성에 대한 내용을 헷갈려서 81점을 받았다. 처음에는 2개 이상의 속성 조합으로 구성된 후보키일 때, 그 중 하나의 속성이라도 후보키가 된 적이 있으면 최소성을 만족하지 않는 것으로 생각했다. 그래서 한 번이라도 후보키가 된 적 있는 속성이면 해당 속성을 포함한 속성 조합들은 키가 안되는 것으로 map을 통해 처리했다. 

예를 들면 [1, 3] 이라는 키가 있을 때 [1, 2, 4]라는 키는 1이 공통적으로 포함되어 있기 때문에 안되는 줄 알았다. 

최소성을 만족시키지 않는 것은 [1]은 키가 아니고 [1, 3]는 키일 때, [1, 3]이 포함되어 있는 [1, 2, 3]이 후보키가 안되는 경우에 해당한다.
